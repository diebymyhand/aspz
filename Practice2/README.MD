# Завдання загальне для всіх
# Завдання 2.1

Умова: 
Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

Результат:
![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.1/1.png)

На 32-бітній системі time_t досягає межі 19 січня 2038 року (INT_MAX), після чого виникає переповнення. На 64-бітній системі (LLONG_MAX) значення занадто велике, і функція ctime() повертає NULL.

---

# Завдання 2.2

Умова:
Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента
BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.2/1.png)
Базова програма без додаткових даних, тому розмір text відповідає коду програми, а data і bss містять мінімальні дані.

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.2/2.png)
Масив із 1000 int додав 4000 байт до сегмента bss, оскільки він не ініціалізований.

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.2/3.png)
Заповнений глобальний масив переміщається з BSS-сегмента у DATA-сегмент.

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.2/4.png)
Локальні масиви у функціях не впливають на розмір сегментів data або bss, оскільки вони виділяються під час виконання програми (у стеку). Однак розмір сегмента text збільшився через додавання коду для роботи з цими масивами.

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.2/5.png)
Під час компіляції з увімкненим налагодженням до виконуваного файлу додається додаткова інформація для відлагодження, що збільшує його розмір. Використання максимальної оптимізації зменшує обсяг сегмента .text, але не впливає на сегменти .data і .bss.

---

# Завдання 2.3

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.3/1.png)
Сегмент .text містить код функцій (адреса increase_stack), сегмент .data — глобальні змінні (global_var), купа розміщується динамічно через malloc, а стек — для локальних змінних (i, array). Зі збільшенням розміру локальних масивів вершина стека зміщується вниз (до менших адрес).

---

# Завдання 2.4

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/task2.4/1.png)
gstack показує стек викликів активного процесу, наприклад, які функції викликаються у певний момент. Це зручно для швидкої перевірки «завислої» програми. GDB дозволяє зупинити виконання, подивитися значення змінних, перейти в конкретну функцію й покроково налагоджувати код.

---

# Завдання по варіантах
# Завдання 5

Завдання:
Реалізуйте стекову машину, що використовує сегмент стека для
обчислень.

![](https://github.com/diebymyhand/aspz/blob/main/Practice2/var5/main.png)
У програмі реалізовано калькулятор, який використовує стек для обчислень у зворотній польській нотації (RPN). Користувач вводить вирази, де числа і операції (наприклад, "3 4 + 2 *") обробляються по черзі.
1. Спочатку створюється стек для зберігання чисел.
2. Користувач вводить вирази, розділені пробілами.
3. Якщо введено число, воно додається в стек.
4. Якщо введено оператор (+, -, *, /), програма забирає два числа зі стеку, виконує операцію і результат повертається в стек.
5. Після виконання виразу виводиться результат, що знаходиться на верхівці стеку.
Для виходу з програми користувач повинен написати "exit".





















