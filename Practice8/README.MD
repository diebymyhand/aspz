# Завдання загальне для всіх
# Завдання 8.1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

![](https://github.com/diebymyhand/aspz/blob/main/Practice8/task8.1/1.png)

Виклик write може повернути кількість записаних байт, яка відрізняється від запитаної. 
У коді причина неповного записування — це використання неблокувального режиму для каналу, встановленого через fcntl(pipefd[1], F_SETFL, flags | O_NONBLOCK);.
У неблокувальному режимі функція write може повернути значення, менше за запитане, якщо канал не готовий до запису, тобто коли в каналі немає достатньо місця для всіх байт. В такому випадку write може записати тільки частину даних або повернути помилку, вказуючи на те, що запис неможливий через тимчасову відсутність місця.

---

# Завдання 8.2

Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

![](https://github.com/diebymyhand/aspz/blob/main/Practice8/task8.2/1.png)

Після виклику функції read(fd, buffer, 4) буфер буде містити значення, зчитані з файлу, починаючи з 4-го байта, після того, як вказівник на позицію читання був переміщений за допомогою lseek(fd, 3, SEEK_SET) на 3-ю позицію в файлі.

---

# Завдання 8.3

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

![](https://github.com/diebymyhand/aspz/blob/main/Practice8/task8.3/1.png)

У даній програмі проводиться тестування функції сортування qsort на різних типах масивів:
- Відсортований масив
- Відсортований у зворотному порядку
- Випадковий масив
- Масив з однакових елементів

Після кожного тестування програма підраховує час, витрачений на сортування, та перевіряє коректність сортування. Якщо масив не відсортовано коректно, програма виводить повідомлення про помилку.

---

# Завдання 8.4

 Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

![](https://github.com/diebymyhand/aspz/blob/main/Practice8/task8.4/1.png)

При виклику fork() у програмі створюється новий процес, який є копією батьківського процесу, але з новим ідентифікатором процесу PID. 
Функція fork() повертає:
- В батьківському процесі — PID нового процесу.
- В дочірньому процесі — 0.

---

# Завдання по варіантах
# Варіант 5

Напишіть програму, яка симулює збій у середині операції write() і спробуйте зберегти цілісність даних.

![](https://github.com/diebymyhand/aspz/blob/main/Practice8/var5/1.png)

Програма спочатку створює тимчасовий файл data.tmp і записує в нього частину даних, що імітує збій. Потім файл повністю перезаписується, а після успішного завершення запису викликається функція rename(), яка атомарно перейменовує data.tmp на data.txt. 
Якщо файл data.txt не існує, він буде створений, а якщо вже є - замінений. Завдяки цьому у файлі data.txt завжди зберігаються лише коректні та повні дані, навіть якщо на попередньому етапі стався збій.

