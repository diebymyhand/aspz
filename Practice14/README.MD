# Варіант 5

Дослідіть, як поводиться таймер у стані sleep/suspend (через CLOCK_MONOTONIC vs CLOCK_REALTIME).

![](https://github.com/diebymyhand/aspz/blob/main/Practice14/1.png)

Програма вимірює значення обох таймерів до та після виклику функції sleep(5), яка зупиняє виконання програми на 5 секунд.

CLOCK_REALTIME - це системний таймер, який відображає реальний час. Він синхронізується з годинником системи і може змінюватися зовнішніми чинниками, наприклад користувачем. 
У режимі sleep() або навіть suspend, цей таймер продовжує йти, тому що він базується на реальному фізичному часі. Тобто навіть якщо процесор "спить", година доби змінюється, і CLOCK_REALTIME це враховує.

CLOCK_MONOTONIC - це системний таймер, який відраховує час, що минув з моменту запуску системи. Він не залежить від зміни системного часу і не зупиняється навіть у режимі sleep(), але може припинити відлік у стані suspend. Його значення завжди зростає й не може відкотитися назад. 
У звичайному Linux CLOCK_MONOTONIC призупиняється у стані suspend, але продовжує йти під час sleep(), бо sleep() - це просто затримка виконання процесу, а не призупинення всієї системи.

Оскільки я працюю через WSL, CLOCK_MONOTONIC не зупиняється навіть у разі призупинення процесу або переходу системи в стан сну. 
Це пов’язано з тим, що WSL працює всередині Windows, і Linux-процеси не мають прямого доступу до апаратного керування енергозбереженням, як у звичайному Linux. 
Через це CLOCK_MONOTONIC продовжує відраховувати час безперервно, незалежно від сну чи призупинки, що може відрізнятися від очікуваної поведінки на нативній Linux-системі.
