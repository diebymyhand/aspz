# Завдання загальне для всіх
# Завдання 4.1

Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.1/1.png)

За один виклик malloc(3) можна виділити пам'ять, обсяг якої обмежений максимальним значенням типу size_t. Оскільки size_t є цілим числом, максимальний обсяг пам'яті, який можна виділити, дорівнює 2^64 байт. Однак на 64-бітових системах цей ліміт буде меншим за 16 ексабайт, оскільки операційна система та архітектура можуть накладати додаткові обмеження на кількість пам'яті, яку можна виділити за один раз.

---

# Завдання 4.2

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.2/1.png)

Якщо передати від’ємне значення, malloc інтерпретує його як дуже велике число, оскільки тип size_t є беззнаковим. Тому malloc поверне NULL.
Якщо результат множення виходить за межі типу int, то malloc також поверне NULL. 

---

# Завдання 4.3

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.3/1.png)


Поведінка malloc(0) залежить від системи: іноді повертає NULL, іноді - робочий вказівник. У моєму випадку він повернув ненульовий вказівник. 
У будь-якому випадку цей вказівник можна безпечно передати у free().
Отже, програма показує, що malloc(0) не обов’язково означає помилку, але така памʼять не використовується, а тільки звільняється.

--- 

# Завдання 4.4

Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.4/wrong.png)

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.4/right.png)

У початковому коді в кінці кожної ітерації free(ptr) звільняє памʼять, але ptr усе ще вказує на вже звільнену область. Також через те, що ptr не скидається до NULL, умова if (!ptr) пропускає виділення нової памʼяті - і програма продовжує працювати з уже звільненою.

---

# Завдання 4.5

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.5/1.png)

Функція realloc() при невдалому виділенні пам’яті повертає NULL, але початковий вказівник залишається дійсним.
Тестовий приклад показує, що при запиті надмірного обсягу пам’яті realloc() завершується з помилкою, а попередній блок потрібно звільнити вручну.


---

# Завдання 4.6

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.6/1.png)

Якщо викликати realloc(NULL, size), то він поводиться так само, як malloc(size) і виділяє пам'ять.
Якщо викликати realloc(ptr, 0), то це звільняє пам'ять, яку ми виділили раніше, і поверне NULL.

---

# Завдання 4.7

Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/task4.7/1.png)

Програма з reallocarray працює подібно до програми з realloc, але має перевагу — автоматичне обчислення розміру пам'яті, що зменшує ймовірність помилок. При порівнянні з ltrace різниця між функціями полягає лише в способі обчислення розміру пам'яті: в realloc потрібно множити кількість елементів на їх розмір вручну, а в reallocarray це робить сама функція.

---

# Завдання по варіантах
# Завдання 5

Використайте mprotect для створення області пам’яті, що неможливо змінювати.

![](https://github.com/diebymyhand/aspz/blob/main/Practice4/var5/1.png)

Програма виділяє блок пам'яті за допомогою функції mmap, в якому спочатку дозволено як читати, так і записувати дані. Після цього вона змінює права доступу до цієї пам'яті, дозволяючи лише читання, використовуючи функцію mprotect. Однак, після зміни прав доступу програма намагається записати дані в пам'ять, що стає недоступною для запису, що викликає помилку (сегментаційну помилку), оскільки система не дозволяє змінювати цю пам'ять.

